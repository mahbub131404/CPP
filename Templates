Hey buddy! ğŸ‘‹ Today, weâ€™re going to learn about Templates in C++! ğŸŒŸ

ğŸ”¹ What Are Templates?
1.
Imagine you have a box ğŸ“¦ where you can put different things like toys, books, 
or clothes. But instead of making a new box for each thing, you make one box 
that works for everything!

ğŸ‘‰ In C++, Templates allow us to write one piece of code that works for any 
data type (like int, double, string, etc.).

ğŸ“Œ Example of a Simple Template
#include <iostream>
using namespace std;

template <typename T>  // Template with type T
class Box {
public:
    T item;
    Box(T i) { item = i; }
    void show() { cout << "Item: " << item << endl; }
};

int main() {
    Box<int> intBox(10);    // Box with int
    Box<double> dblBox(5.5); // Box with double
    Box<string> strBox("Hello!"); // Box with string

    intBox.show();
    dblBox.show();
    strBox.show();

    return 0;
}
ğŸ”¹ Output:
Item: 10
Item: 5.5
Item: Hello!

ğŸš€ This class can store any type of data!

2. 
Imagine you have a magic cookie cutter ğŸª that can make cookies of 
any shape (circle, square, star). Instead of making different 
cookie cutters for each shape, you make one cutter that works for all!

ğŸ’¡ In C++, Templates allow us to write one function or class that works 
for any data type (like int, double, string), so we donâ€™t have to write 
the same code multiple times!

ğŸ”¹ Why Use Templates?
ğŸ“Œ Without Templates:
If we want a function that adds two numbers, we have to write different versions for int, double, and float:

int add(int a, int b) { return a + b; }
double add(double a, double b) { return a + b; }
float add(float a, float b) { return a + b; }
ğŸ‘ Too much repeated code!

ğŸ“Œ With Templates
ğŸ‘‰ One function for ALL data types!

template <typename T>  // T is a placeholder for any type
T add(T a, T b) {
    return a + b;
}

int main() {
    cout << add(5, 10) << endl;       // Works for int
    cout << add(5.5, 2.5) << endl;   // Works for double
    cout << add(2.2f, 3.3f) << endl; // Works for float
    return 0;
}
ğŸ”¹ Output:

15
8
5.5
ğŸš€ Now, we have only one function that works for all data types!

ğŸ”¹ Function Templates
ğŸ“Œ Example: Swapping Two Values
ğŸ‘‰ A function that swaps two values of any type!


#include <iostream>
using namespace std;

template <typename T>
void swapValues(T &a, T &b) {
    T temp = a;
    a = b;
    b = temp;
}

int main() {
    int x = 10, y = 20;
    swapValues(x, y);
    cout << "Swapped: " << x << ", " << y << endl;  // Output: 20, 10

    double p = 1.1, q = 2.2;
    swapValues(p, q);
    cout << "Swapped: " << p << ", " << q << endl;  // Output: 2.2, 1.1

    return 0;
}
ğŸ”¹ Output:


Swapped: 20, 10
Swapped: 2.2, 1.1
ğŸš€ Works for any type!

ğŸ”¹ Class Templates
ğŸ“Œ A class that works for all data types!

ğŸ“Œ Example: Creating a Storage Box
ğŸ‘‰ A class that can store any type of data!


#include <iostream>
using namespace std;

template <typename T>  
class Box {
private:
    T item;
public:
    Box(T i) { item = i; }
    void show() { cout << "Item: " << item << endl; }
};

int main() {
    Box<int> intBox(100);      // Integer Box
    Box<double> dblBox(5.5);   // Double Box
    Box<string> strBox("Hey!"); // String Box

    intBox.show();
    dblBox.show();
    strBox.show();

    return 0;
}
ğŸ”¹ Output:


Item: 100
Item: 5.5
Item: Hey!
ğŸš€ Now, our class works for int, double, and string!

ğŸ”¹ Multiple Template Parameters
ğŸ“Œ A class with two different types!

ğŸ“Œ Example: A Pair Class
ğŸ‘‰ This class stores two values of different types!


#include <iostream>
using namespace std;

template <typename T1, typename T2>
class Pair {
private:
    T1 first;
    T2 second;
public:
    Pair(T1 f, T2 s) : first(f), second(s) {}
    void show() { cout << "Pair: " << first << ", " << second << endl; }
};

int main() {
    Pair<int, double> p1(10, 5.5);
    Pair<string, int> p2("Age", 25);

    p1.show();  // Output: Pair: 10, 5.5
    p2.show();  // Output: Pair: Age, 25

    return 0;
}
ğŸ”¹ Output:


Pair: 10, 5.5
Pair: Age, 25
ğŸš€ Now, our class can store two different types together!

ğŸ”¹ Specialized Templates
ğŸ“Œ Sometimes, we want a special version of a template for a specific data type!

ğŸ“Œ Example: Specializing for char***
ğŸ‘‰ This function behaves differently when used with char*!


#include <iostream>
using namespace std;

template <typename T>
void show(T value) {
    cout << "Generic Value: " << value << endl;
}

// Specialization for char*
template <>
void show<char*>(char* value) {
    cout << "Specialized for string: " << value << endl;
}

int main() {
    show(100);      // Calls generic function
    show(5.5);      // Calls generic function
    show("Hello!"); // Calls specialized function

    return 0;
}
ğŸ”¹ Output:


Generic Value: 100
Generic Value: 5.5
Specialized for string: Hello!
ğŸš€ Specialized behavior for char*!

ğŸ”¹ Summary
âœ” Templates allow us to write one function or class for all data types.
âœ” Function Templates make one function work for different types.
âœ” Class Templates make one class work for different types.
âœ” Multiple Parameters allow templates to handle more than one type.
âœ” Specialized Templates modify templates for specific types.

ğŸš€ Final Thoughts
ğŸ”¥ Now you understand Templates in C++! ğŸ¯
ğŸ’¡ Try making your own Template Functions and Classes!
